<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[As a SW/Ops/DB Engineer]]></title>
  <link href="http://tech.riywo.com/atom.xml" rel="self"/>
  <link href="http://tech.riywo.com/"/>
  <updated>2013-04-17T18:45:55-07:00</updated>
  <id>http://tech.riywo.com/</id>
  <author>
    <name><![CDATA[riywo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[multiple assignment from regexp]]></title>
    <link href="http://tech.riywo.com/blog/2013/04/17/multiple-assignment-from-regexp/"/>
    <updated>2013-04-17T18:22:00-07:00</updated>
    <id>http://tech.riywo.com/blog/2013/04/17/multiple-assignment-from-regexp</id>
    <content type="html"><![CDATA[<p>Sometimes I want to assign multiple variables from results of regexp matching. Here are the ways in some LLs.</p>

<!-- more -->


<h3>Perl</h3>

<pre><code>my ($a, $b) = ("a:1 b:2" =~ /a:(\d) b:(\d)/);
</code></pre>

<h3>Ruby</h3>

<pre><code>a, b = "a:1 b:2".match(/a:(\d) b:(\d)/) {[$1, $2]}
# or
a, b = "a:1 b:2".match(/a:(\d) b:(\d)/).to_a[1, 2]
</code></pre>

<h3>Python</h3>

<pre><code>import re
a, b = re.match(r'a:(\d) b:(\d)', "a:1 b:2").group(1, 2)
</code></pre>

<h2>Conclusion</h2>

<ul>
<li>Perl

<ul>
<li>simplest</li>
<li>needs parentheses</li>
</ul>
</li>
<li>Ruby

<ul>
<li>match is a method of <code>String</code> class</li>
<li>give a block or slice an array</li>
</ul>
</li>
<li>Python

<ul>
<li>needs <code>re</code> module</li>
<li>match is a method of <code>re</code></li>
</ul>
</li>
</ul>


<p>Enjoy!</p>

<hr />

<p>簡単にファイルをパースしたい時とかに、Perlで書いた正規表現でさくっと変数に多重代入したりしてたんですが、Ruby/Pythonだとどうやるのか分からなかったのでまとめ。Thanks to @_shimada, @methane, @kyoendo</p>

<p>namedcapture版も作ってみたい。というかそもそもオレオレLL比較チートシート作りたい。</p>

<ul>
<li>参考

<ul>
<li><a href="http://0xcc.net/blog/archives/000137.html">文字列操作の比較表: Ruby, Python, JavaScript, Perl, C++ - bkブログ</a></li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Awesome Docker!そして環境管理について思うところ]]></title>
    <link href="http://tech.riywo.com/blog/2013/04/17/awesome-docker/"/>
    <updated>2013-04-17T01:16:00-07:00</updated>
    <id>http://tech.riywo.com/blog/2013/04/17/awesome-docker</id>
    <content type="html"><![CDATA[<p>最近個人プロダクトでやってたことは、</p>

<ul>
<li><a href="https://github.com/riywo/myroku-cookbooks">Myroku</a>

<ul>
<li>private PaaS</li>
<li>社内とかで自由にHerokuっぽいことやりたい</li>
</ul>
</li>
<li><a href="https://github.com/riywo/pandler">Pandler</a>

<ul>
<li>package isolation</li>
<li>rpmを完璧に管理した環境を作りたい</li>
</ul>
</li>
</ul>


<p>みたいな感じなんですが、一人でスキマ時間で頑張ってたものなのでクオリティは最低ですし、全然完成しませんでした。本当に作る才能がない。</p>

<p>というところで、ネットサーフィンしてたら、最近dotCloudがDockerというのをOSSで出したということを知りました。</p>

<ul>
<li><a href="http://www.docker.io/">Docker - the Linux container runtime</a></li>
<li><a href="http://www.infoq.com/news/2013/03/Docker">Docker: Automated and Consistent Software Deployments</a></li>
</ul>


<p>dotCloudはPaaSをやってる会社で、DockerはLXC(Linux Container)を使った実行環境管理ツールの様です。dotCloudの社内でも使われているものみたいですね。</p>

<!-- more -->


<h2>隔離環境</h2>

<p>Pandlerでやりたかったことは、chrootで全く新しいroot filesystemを作ってそこにrpmを完璧に管理してインストールしプロセスを実行することだったんですが、DockerはLXCを使ってそれを実現してます。正確にはパッケージ管理の部分はLXCのイメージ？(実はLXC触ったことない。。。)にしてるのでDSL的な管理はできていないですが、実行環境をホストから隔離して実行するという意味では同じです。というか、Vagrant、ひいてはprivate cloud全般も同じ感じですね。</p>

<p>実際、PaaS的なことをやろうと思うとなにがしかの方法で環境を隔離して管理しないといけなくて、Herokuもdynoという単位でVMを表現していますが、これもLXCの様です。</p>

<p>Myrokuではもっと単純なアプローチで、LLの実行環境(処理系＋ライブラリ群)のみを固定化してプロセスを立ち上げればいいかなと思い、自作の<a href="https://github.com/riywo/ruby-llenv">llenv</a>を使って、LLの処理系およびLLのライブラリ群を1ディレクトリに入れて実行するという方式を取りました。ついでにそれをcapistranoで配布して、フロントのHTTPリバースプロキシと連携してポート番号を割り当てて、VirtualHostで出し分ける、みたいなところまでやりました。</p>

<p>一方、Pandlerはchrootを使って固定化してみました。chrootの良い点は変なオーバヘッドなくシンプルに使えることと、IPアドレス始めリソースの配分を考える<strong>必要が無い</strong>ということだと思います。Pandlerは利用者にはchrootであることを意識しなくても実行できるような感じをイメージしていたので、そういう面倒事をなるべく排除したかったです(LXC詳しくないので実はそういうことやらなくて済む方法もあるのかも知れません)。あと、rootユーザじゃなくても実行できたらと思ってfakechrootとかも見てました。</p>

<p>環境の隔離をもっとも素直にやるなら、今は各種仮想マシンを利用するのが手っ取り早いですね。XenやVMware、KVMにVirtualBox、果てはそれらをまとめて管理する環境(OpenStackとか)まで、もうすでにたくさんの選択肢がありますが、僕がやってきたようなやり方も環境隔離の一つのやり方だと思います。</p>

<h2>なんで必要なの？</h2>

<p>僕がどうしてここまでこの分野にこだわってるかというと、別にPaaSがやりたいわけではなくて、プロセスの実行環境(特にファイル資源)を出来る限りホストOSそれ自身から切り離したいからです。</p>

<p>なぜ？それはOSのインストール自体＝Kernelを起動するまでと、アプリケーションを動かすレイヤを分けることで、様々なインフラ上で同じアプリケーションを動作させることができるようになるからです。（ただし僕の頭の中ではLinuxのことしか考えてません）</p>

<p>様々なインフラとは、仮想マシンやパブリッククラウド、VPSやオンプレミスなサーバなどです。これらの間でOSおよびパッケージ群を完全に揃えることは大変に困難を極めます。それぞれの環境でサポートしているディストリやバージョンが違ったりしますし、諸々の理由で既にインストールされているものと衝突する場合もあります。ChefやPuppetなどの構成管理ツールでホストOSを管理する方法をとってもこれは解決しません。</p>

<p>じゃあ、JVMの様にそれぞれの環境上にVMを入れてしまえばいいじゃない、つまり、どの環境であれとにかくKVMなりを使える様にしてしまえばイメージの使い回しができる、というのはまぁそのとおりなんですが、それじゃあどの環境も使うメリットがありません。オンプレミスを使いたい場面は大抵ハードウェアのスペックを使い切りたいわけですし、クラウドのサーバで仮想マシンを動かすのはなんかおかしいです(もちろんクラウド自身がそのイメージを使えればいいですが)。</p>

<p>最近は、LLの処理系は**env的なツールを使って一般ユーザでビルドからやってしまえば、ホストOSに依存せずにどこでも同じ環境が再現できる！という意見も出てきそうですが、結局ホストOSに入っているライブラリ(libなんとかとか)は使っちゃうわけで、そのバージョンが違えば当然挙動が変わってしまいます。これは処理系だけじゃなくて、その後インストールするLL自身のパッケージも同様で、C拡張系のパッケージは激しくホストOSに依存しますので、BundlerやCartonを使った管理も100%完璧ではありません。</p>

<p>僕が最近思ってるよさげな妥協点としては、Dockerの様にKernelは環境によって差異があるかもしれないけど、アプリケーションのファイル資源はホストOSとは完全に切り離されていて、libなんとかも全部自前で揃えている環境と必ずセットで管理するのがいいと思ってます。</p>

<h2>Bundled application</h2>

<p>ファイル資源をアプリケーションとセットにすることで、このファイルをコピーして実行するだけで、アプリケーションを簡単にどこでも再現できます。もちろんLXCを使うならLXCが使えるKernelじゃないとダメですが、逆にいうとそこさえクリアすればいいわけです。実際、DockerはEC2でも動くみたいです。</p>

<p>で、こうすることでなにがいいのか？例えばあるサービスをEC2で始めたとして、成長に伴い次はVPS、最後はオンプレミスへと移行するというケースや、反対にオンプレミスのサービスの縮小に伴いEC2に移行したいといったケースで威力を発揮します。こうした移行は大抵ものすごい労力を伴います。ただでさえ開発に忙しいのに、コスト計算・比較もしなくちゃいけないし、いろんな他のシステム(DNSとかLBとか)も一式移さなきゃいけない。その上、移行したらOSのバージョン相違やライブラリの相違で動かなくなるかもしれない恐怖と戦うには、相当の体力が必要になります。実行環境がある程度切り離せていれば、そこまで苦もなく移せる可能性が高まります。</p>

<p>また、開発環境と本番環境の差異も減らせます。開発環境は仮想マシン、本番環境はオンプレミスみたいなケースはよくあると思いますが、どうしてもいろんな差分が生まれてしまい、それを綺麗に揃えることに労力を割けるのはこれまた相当な体力がないと続きません。Bundledであれば、(もちろん設定ファイルとかは出し分けますが)一式同じライブラリで開発から本番に持っていくことができますし、テストもしやすくなります。</p>

<p>Ops的にも利点があります。モニタリングに必要なツール一式をBundledできれば、それをとにかく配布すればどんな環境であれおなじ監視ツールがすぐ使える(cgroupsで他のプロセス見えないとかどうすんだろ)とか、アプリケーションがなんであれOSインストール時は自由に作ることができるから、その環境特有の設定や監視を統一的に管理できるとかもできそうです。例えばこのデータセンタはこのネットワークの設定が必要、みたいなのってアプリケーションからはなるべく切り離したいですよね。</p>

<h2>DockerとかTravisとかMesos</h2>

<p>で、まぁこういうことをそもそも既にやってるのがPaaSなんですが、中々その中の仕組みが実装レベルで外に出てくることはなかったので、Dockerはちょっと参考にしたいと思います。もしくは使ってみたい。</p>

<p>あと、Travis CIみたいなテスト環境系も実は同じようなことをやっているなと思って、前に手元で動かしてみようと試みたことがあることを書いておきます。萎えてやめましたが。</p>

<p>おまけで、MesosってのがLXCをもっと高度に抽象化して、クラスタで並べたnodeのmemoryとcpuリソースをアプリケーションに適切に配分するとかやってるみたいですが、詳しくは知りません。Twitterはガシガシ使っているそうです。</p>

<ul>
<li><a href="http://incubator.apache.org/mesos/">Apache Mesos: Dynamic Resource Sharing for Clusters</a></li>
</ul>


<h2>おわりに</h2>

<p>Dockerが良さそうだなぁと思ったので、ここ最近考えてることを合わせて言語化しておきました。英語で書くには英語力が足りないのと誰にも読んでもらえないorz</p>

<p>問題はこれが所詮POCで、こういうことを実際にやるモチベーションは特にないので、机上の空論感がとても強いこと。多少の環境の差異はなんとなく乗りきれちゃったりするしそもそも完璧に管理する必要ないことが多い。もしくは寿命ギリギリまで環境を出来る限り変えずにやり過ごすのが一番簡単なやり方なので、今頑張る必要なくて、そしてずっと頑張る必要がないような話題だったりもします。この辺はサービスのライフサイクルとかも絡めて話をしたいところです。</p>

<p>ただ夢を見続けることはした方がいいのかなと思うのと、そもそもその夢間違ってるよってのも言って欲しくてとりあえず書きなぐっておきました。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tech Blog始めました&ブログの始め方]]></title>
    <link href="http://tech.riywo.com/blog/2013/04/16/test-entry/"/>
    <updated>2013-04-16T22:51:00-07:00</updated>
    <id>http://tech.riywo.com/blog/2013/04/16/test-entry</id>
    <content type="html"><![CDATA[<p>このエントリを読んで、そういえば最近全くアウトプットができていないことにはたと気づきました。@sunaot++</p>

<p><a href="http://sunaot.tumblr.com/post/48053101279/4">4 月にエンジニアとなった人たちに知っておいてもらいたいこと</a></p>

<p>というわけで、「そうだ、ブログを書こう」となりました。メインのブログの方で書いてもいいんですが、なんとなく技術寄りのものは別にまとめてみたいなぁと思って、最近流行りのOctopress+Github Pagesで作ってみました。このブログの作り方を共有するところからまずは出発しようかと思います。</p>

<ul>
<li><a href="http://tech.riywo.com/">As a SW/Ops/DB Engineer</a></li>
</ul>


<!-- more -->


<p>とは言っても、ドキュメントがよくできてるので特に解説することはありませんでした。。。</p>

<ul>
<li>参考サイト

<ul>
<li><a href="http://octopress.org/docs/">Octopress Documentation - Octopress</a></li>
<li><a href="https://help.github.com/categories/20/articles">GitHub Help</a></li>
<li><a href="http://www.miukoba.net/blog/2013/01/05/start-octopress/">Octopressはじめました - mimemo</a></li>
</ul>
</li>
</ul>


<h2>local setup</h2>

<ul>
<li><a href="http://octopress.org/docs/setup/">Octopress Setup - Octopress</a></li>
</ul>


<p>まずはこれに従ってローカルにファイルを落とす。rbenv使ってて、<code>.rbenv-version</code>のが入って無かったので<code>rbenv local</code>で適当に自分の持ってるバージョンを指定。<code>bundle</code>はいつも通り<code>bundle install --path vendor/bundle --binstubs</code>。<code>--binstubs</code>用に<code>.bash_profile</code>とかで<code>export PATH="./bin:$PATH"</code>してます。</p>

<p><code>rake install</code>したら次へ。</p>

<h2>github setup</h2>

<ul>
<li><a href="http://octopress.org/docs/deploying/github/">Deploying to Github Pages - Octopress</a></li>
</ul>


<p>githubにはpagesという静的コンテンツ配信をしてくれる仕組みがあります。これを利用してかつカスタムドメインで自分のドメインを使います(github.com=>github.ioに勝手にドメインが変えられたりするので、パーマリンク厨的には自分のドメインで配信したいのです)。</p>

<p>ところが、github pagesのカスタムドメインは<strong>1ユーザ</strong>につき1つしか設定できないので、プロジェクト毎のページのリンクはusername.github.io/projectになってしまいます。僕は既に別のサイトを自分のgithub pagesで配信してるのでさて困った。</p>

<p>というわけでorganizationを使います。organizationのメインgithub pagesにもカスタムドメインが設定できるからですね。publicなレポジトリであればorganizationを作るのは無料なのでこのブログ専用のorganizationを作りました。</p>

<p>そうしたら、ブログ用のレポジトリを作ります。名前は必ず<code>organame.github.io</code>になります。もちろんpublic。</p>

<p>作ったら<code>git@github.com</code>で始まるパスをコピーしておいて、おもむろに<code>rake setup_github_pages</code>を実行。URLを聞かれたらさっきのを入力。あとは<code>rake generate</code>, <code>rake deploy</code>したら、<code>http://organame.github.io</code>でもう見れるはず。github++</p>

<h3>custom domain</h3>

<ul>
<li><a href="https://help.github.com/articles/setting-up-a-custom-domain-with-pages">Setting up a custom domain with Pages · GitHub Help</a></li>
</ul>


<p>カスタムドメインもそんなに難しくない。上記の通り、TLDならAレコード、それ以外ならCNAMEを設定。あとは、<code>echo orgname.example.com &gt;&gt; source/CNAME</code>として、先ほどの<code>rake</code>を再実行すれば終わり。</p>

<h2>source repo</h2>

<p>さて、先ほど<code>orgname.gihub.io</code>にpushされたのはOctopressによって生成された静的コンテンツなわけですが、それらの元になっているファイルも当然githubで管理したくなります。</p>

<p>別にpublicで良ければOctopressの手順通り、<code>git push origin source</code>とすれば、先ほどのorganizationのレポジトリに<code>source</code>ブランチができて完了です。</p>

<p>僕はなんとなくsourceはprivateにしたかったのでちょっと変なやりかたをしました。自分のユーザ配下にprivateレポジトリを作成して、そこに向けてpushするようにします。多分こんな感じでいけるはず。</p>

<pre><code>$ git remote add private PRIVATE_REPO_URL 
$ git config branch.source.remote private
$ git push -u private source
</code></pre>

<p>これで<code>git push</code>すればsourceはprivateの方にいきます。</p>

<h2>configuration</h2>

<p><code>_config.yml</code>を見ながら適当に編集。そのうち頑張る。</p>

<h2>first post</h2>

<p>あとはエントリを書くだけ。<code>rake new_post['post title']</code></p>

<p>とりあえずMouを試用してます。ただ、<code>rake preview</code>としておけばローカルにサーバ立ててくれてリアルタイムに反映されるので、リロードするだけでプレビューできるので要らないかも。</p>

<h1>おわりに</h1>

<p>今日は日本人のハッカーの方達と晩御飯食べましたが、みなさんかっこよくてちょっとでも近づけるように頑張ろうと思えて、とても元気出ました。このブログが誰かの何かの役に立てば幸いです。たまに日本語だったりたまに英語だったりすると思います。書きやすさとその日の気分重視。</p>
]]></content>
  </entry>
  
</feed>
